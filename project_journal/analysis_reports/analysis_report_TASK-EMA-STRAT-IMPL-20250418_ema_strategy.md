# Analysis Report: Implementing Original EMA Strategy in SpreadPilot

**Task ID:** TASK-EMA-STRAT-IMPL-20250418
**Date:** 2025-04-18
**Author:** Roo Complex Problem Solver

## 1. Problem Statement

The objective is to implement the customer's original EMA crossover trading strategy, previously running on a legacy system (OLD_CODE), into the modern SpreadPilot platform. The core requirement is to replicate the exact trading logic (EMA 7/21 crossover on 5-min bars for SOXS/SOXL, 1% trailing stop, EOD close, $10k fixed size, IBKR execution) before considering any enhancements. This analysis details the feasibility, challenges, and recommended implementation approach.

## 2. Analysis Performed

*   **Tools Used:** `read_file`
*   **Files Reviewed:**
    *   `docs/old_code_vs_spreadpilot_comparison.md`
    *   `docs/original_strategy_implementation_plan.md`
    *   `trading-bot/app/main.py`
    *   `trading-bot/app/config.py`
    *   `trading-bot/app/service/base.py` (TradingService)
    *   `trading-bot/app/service/ibkr.py` (IBKRManager)
    *   `trading-bot/app/service/alerts.py` (AlertManager)
    *   `trading-bot/app/service/positions.py` (PositionManager)
    *   `trading-bot/app/service/signals.py` (SignalProcessor)
    *   `spreadpilot-core/spreadpilot_core/ibkr/client.py` (IBKRClient)
*   **Key Findings:**
    *   **Architectural Mismatch:** SpreadPilot's `trading-bot` is fundamentally designed as a follower-centric system that processes external signals (from Google Sheets) to execute option spread trades. It is not currently set up to generate trading signals internally based on real-time market data and strategy logic (like the EMA crossover).
    *   **Component Suitability:**
        *   `IBKRManager` and `PositionManager` are tightly coupled to the follower model and option-specific logic (assignments), making them unsuitable for managing the single-account, stock-based EMA strategy.
        *   The core `IBKRClient` (`spreadpilot-core`) lacks essential generic functionalities required by the EMA strategy: fetching historical bars, creating stock contracts, placing generic MKT/TRAIL orders for stocks, and retrieving stock positions. It is currently tailored for QQQ option spreads.
        *   `AlertManager` is suitable for receiving and logging alerts generated by the new strategy.
        *   `SignalProcessor` is irrelevant as the EMA strategy generates signals internally.
    *   **Initial Plan Deficiencies:** The `docs/original_strategy_implementation_plan.md` provided a good structural starting point but underestimated the architectural mismatch. Its proposed integration points (registering strategy in `main.py`, direct use of core `IBKRClient` within strategy class, assumptions about existing manager suitability) are incompatible with the actual `trading-bot` design.
    *   **Constraint:** Analysis relies on the provided strategy specifications, as direct access to `OLD_CODE` source files was not possible. Verification against original source code is recommended during implementation.

## 3. Root Cause(s) of Implementation Complexity

The primary challenge stems from the fundamental difference in architectural paradigms:

*   **OLD_CODE:** Monolithic, single-purpose bot executing one strategy based on internal data processing.
*   **SpreadPilot `trading-bot`:** Microservice component within a larger platform, designed as a signal *consumer* for a specific use case (follower-based option spreads), not a signal *generator* for diverse strategies.

Integrating a data-driven, signal-generating strategy requires adapting the `trading-bot`'s core purpose or introducing parallel processing flows.

## 4. Evaluation of Potential Solutions

1.  **Modify Existing `trading-bot` Components:**
    *   **Description:** Refactor `TradingService`, `IBKRManager`, and `PositionManager` to handle both the existing follower logic and the new EMA strategy logic. Modify the main loop to accommodate internal signal generation.
    *   **Pros:** Reuses existing component names.
    *   **Cons:** Extremely complex, high risk of breaking existing functionality, mixes unrelated concerns (followers vs. single strategy), requires deep refactoring of stable components.
    *   **Evaluation:** **Not Recommended.** The risk and complexity heavily outweigh potential benefits.

2.  **Create Dedicated `OriginalStrategyHandler` + Extend Core `IBKRClient`:**
    *   **Description:**
        *   Extend the `spreadpilot-core.ibkr.IBKRClient` with generic methods for historical data, stock contracts, MKT/TRAIL orders, and stock positions.
        *   Create a new component (`OriginalStrategyHandler`) within `trading-bot/app/service/` dedicated to the EMA strategy.
        *   This handler runs its own asynchronous loop, manages a dedicated (extended) `IBKRClient` instance, fetches data, executes strategy logic, manages its own simple position state, places orders, and sends alerts to `AlertManager`.
        *   Modify `TradingService` only to launch and manage the `OriginalStrategyHandler`'s background task.
    *   **Pros:** Clear separation of concerns, isolates new logic, minimizes impact and risk to the existing follower system, allows focused implementation, core client extensions are reusable and improve platform capability.
    *   **Cons:** Requires modifying the shared `spreadpilot-core` library (but these are necessary generic improvements), adds a new component to `trading-bot`.
    *   **Evaluation:** **Recommended.** Offers the best balance of isolation, maintainability, and risk mitigation while enabling the required functionality and improving the core library.

## 5. Final Recommendation

Implement the original EMA strategy by **creating a dedicated `OriginalStrategyHandler` component within the `trading-bot` service and extending the core `IBKRClient` in the `spreadpilot-core` library.**

**Justification:** This approach isolates the new strategy's specific requirements (data fetching, internal signal generation, stock trading, unique state management) from the existing follower-based option spread logic. It minimizes the risk of introducing regressions into the current system and provides a clean, maintainable structure. Extending the core `IBKRClient` adds necessary generic capabilities that will benefit future strategy implementations.

## 6. Refined Implementation Plan (High-Level)

1.  **Extend `spreadpilot-core.ibkr.IBKRClient`:**
    *   Add `async def get_stock_contract(self, symbol: str, exchange: str = "SMART", currency: str = "USD") -> Contract`.
    *   Add `async def request_historical_data(self, contract: Contract, endDateTime: str = '', durationStr: str = '1 D', barSizeSetting: str = '1 min', whatToShow: str = 'TRADES', useRTH: bool = True) -> List[BarData]`. (Leverage `ib.reqHistoricalDataAsync`).
    *   Add `async def place_order(self, contract: Contract, order: Order) -> Trade`. (Leverage `ib.placeOrder`). Ensure it handles MKT and TRAIL orders.
    *   Modify or add `async def request_stock_positions(self, symbols: List[str]) -> Dict[str, float]` to fetch positions for specific stock symbols.
    *   Add unit tests for new/modified methods.
2.  **Update `spreadpilot-core` Dependencies:** Ensure `trading-bot` uses the updated version of the core library.
3.  **Add Configuration (`trading-bot/app/config.py`):**
    *   Define a section `ORIGINAL_EMA_STRATEGY` including: `enabled`, `ibkr_secret_ref` (for dedicated credentials), `symbols` (SOXS, SOXL), `fast_ema`, `slow_ema`, `bar_period`, `trading_start_time`, `trading_end_time`, `dollar_amount`, `trailing_stop_pct`, `close_at_eod`.
4.  **Create `OriginalStrategyHandler` (`trading-bot/app/service/original_strategy_handler.py`):**
    *   `__init__(self, service, config)`: Store service reference, strategy config. Initialize internal state (e.g., `self.ib_client = None`, `self.positions = {'SOXS': 0, 'SOXL': 0}`, `self.symbol_data = {}`).
    *   `async def initialize(self)`: Fetch IBKR credentials using `service.get_secret`, create and connect the dedicated `IBKRClient` instance. Fetch initial positions for SOXS/SOXL. Fetch initial historical data.
    *   `async def run(self, shutdown_event)`: Main loop.
        *   Checks `shutdown_event`, `config.enabled`, and trading hours.
        *   Calculates time until the next 5-min bar closes.
        *   Waits (`asyncio.sleep`).
        *   Fetches the latest 5-min bars for SOXS/SOXL using `ib_client.request_historical_data`.
        *   Calls internal strategy logic (`_process_bar`) for each symbol.
        *   Handles end-of-day logic (`_process_eod`).
    *   `async def _process_bar(self, symbol, bar)`: Contains the core EMA calculation, crossover checks, position sizing, order creation (MKT, TRAIL using `ib_insync` objects), and order placement via `ib_client.place_order`. Updates internal `self.positions` based on fills. Sends alerts via `service.alert_manager.create_alert`.
    *   `async def _process_eod(self)`: If `config.close_at_eod` is true and positions exist, places MKT orders to close them. Sends alerts.
    *   `async def shutdown(self)`: Disconnects the dedicated `ib_client`.
5.  **Integrate with `TradingService` (`trading-bot/app/service/base.py`):**
    *   In `__init__`: Instantiate `self.original_strategy_handler = OriginalStrategyHandler(self, settings.ORIGINAL_EMA_STRATEGY)`.
    *   In `run`: Call `await self.original_strategy_handler.initialize()`. Create and manage the background task: `ema_strategy_task = asyncio.create_task(self.original_strategy_handler.run(shutdown_event))`. Ensure proper handling during shutdown (cancel task, await handler shutdown).
6.  **Testing (See Section 7).**

## 7. Testing and Validation Considerations

*   **Unit Tests:**
    *   `IBKRClient` extensions (data fetching, order placement).
    *   `OriginalStrategyHandler`: EMA calculations, crossover logic, position sizing, order creation logic (mocking IBKRClient).
*   **Integration Tests:**
    *   `OriginalStrategyHandler` interaction with a live (paper) `IBKRClient`. Verify data fetching, order placement (MKT, TRAIL), position updates.
    *   `TradingService` correctly launching and shutting down the handler.
    *   Alert generation via `AlertManager`.
*   **Historical Backtesting:** Crucial for verifying logic against `OLD_CODE`. Requires a separate backtesting environment or script capable of simulating `IBKRClient` responses and feeding historical data to the `OriginalStrategyHandler`. Compare generated trades and P&L against known `OLD_CODE` results.
*   **Paper Trading:** Run the integrated `trading-bot` against an IBKR paper account for an extended period. Monitor logs, trades, and positions closely.
*   **Production Validation (Optional Parallel Run):** If feasible, run the new implementation in production (potentially with reduced size or specific flag) alongside `OLD_CODE` to compare signals and execution in real-time.

## 8. Potential Challenges & Risks

*   **`IBKRClient` Extension Complexity:** Ensuring the new generic methods in the core client are robust and handle edge cases correctly.
*   **`ib_insync` Nuances:** Handling potential issues with the underlying `ib_insync` library (connection drops, errors, API changes).
*   **Historical Backtesting Accuracy:** Ensuring the backtest environment accurately simulates IBKR behavior and market data to provide a valid comparison with `OLD_CODE`.
*   **Trailing Stop Implementation:** Correctly implementing and managing the lifecycle of IBKR TRAIL orders, especially relative to EOD closing logic.
*   **Logic Discrepancies:** Subtle differences between the assumed `OLD_CODE` logic (based on docs) and the actual implementation could lead to performance deviations. Access to `OLD_CODE` source is highly recommended for verification.